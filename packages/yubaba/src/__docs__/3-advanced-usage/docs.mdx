---
name: 3. Advanced usage
route: /advanced-usage
order: 1
---

import { Playground } from 'docz';
import * as Common from 'yubaba-common';
import * as Styled from './styled';
import { WrappedBaba as Baba } from '../../Baba';
import { WrappedBabaManager as BabaManager } from '../../BabaManager';
import CircleExpand from '../../animations/CircleExpand';
import Move from '../../animations/Move';
import CircleShrink from '../../animations/CircleShrink';
import ovi from './images/ovechkin.jpg';

# Advanced usage

## Delay showing content until all animations have finished

Occasionally when initiating an animation we can have some secondary content we want to keep hidden until the animation has finished.
Luckily [BabaManager](/baba-manager) exists to do just that!
Make it a parent of any [Baba](/baba) and it will show its content only when the animation has finished.

> **Tip -** If you have multiple child [Baba](/baba) you can pass [BabaManager](/baba-manager) a `name` prop to target a specific [Baba](/baba).

## Using supporting animations

While movement is a large part of `yubaba` we can do so much more!
When building a great user experience its also useful to have supporting animation to help seamlessly transition from one state to another.

Two extra tools we have to do this is [CircleExpand](/circle-expand) and [CircleShrink](/circle-shrink) animations,
used together can produce a really cool transition between states.

<Playground>
  <Styled.Center>
    <Common.SmallViewport>
      <Common.Toggler>
        {({ shown, toggle }) => (
          <div id="yo">
            {!shown ? (
              <Styled.Container>
                <Baba name="circle-expand-square" key="1">
                  <CircleExpand background="#fea3aa">
                    {({ ref, style }) => (
                      <Styled.Root onClick={() => toggle()} style={style} innerRef={ref} />
                    )}
                  </CircleExpand>
                </Baba>
              </Styled.Container>
            ) : (
              <BabaManager>
                {props => (
                  <Styled.Container
                    onClick={() => toggle()}
                    style={{ cursor: 'pointer', background: '#005aff', ...props.style }}
                  >
                    <Baba name="circle-expand-square" key="2">
                      <CircleShrink background="#005aff">
                        {({ ref, style }) => <div style={style} ref={ref} />}
                      </CircleShrink>
                    </Baba>
                  </Styled.Container>
                )}
              </BabaManager>
            )}
          </div>
        )}
      </Common.Toggler>
    </Common.SmallViewport>
  </Styled.Center>
</Playground>

> **Tip -** [BabaManager](/baba-manager) has been used as well to hide the next contents until the animation has finished,
> resulting in that crisp transition.

## Wait for the previous animation to finish before starting the next

Depending on the animations chosen you'll want to defer starting one until the previous has finished.
Luckily the [Wait](/wait) component has been made for that!

> **Tip -** Animations are executed from top to bottom.
> The parent-most animation will be executed first and then continue execution inwards.

## Moving using a focal target

At times we want to move all content at once but have it originate from a focal point.
The [FocalTarget](/focal-target) component exists to mark the focal element so animations who care can use it.
Two examples of animations who can use it are [Expand](/expand) and [ExpandMove](/expand-move).

<Playground>rodo</Playground>
